// { "framework": "Vue"} 

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 34);
/******/ })
/************************************************************************/
/******/ ({

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(35);


/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var is_touch_device = function () {\n  return 'ontouchstart' in window // works on most browsers\n      || 'onmsgesturechange' in window; // works on ie10\n};\n\nif(!is_touch_device()) {\n  // Phantom Limb\n  // ------------\n  // http://viewinglens.com/phantom-limb\n  // https://github.com/brian-c/phantom-limb\n  // brian.carstensen@gmail.com\n\n  \"use strict\";\n\n  // Default configuration\n  var config = {\n    style: true,\n    startOnLoad: true\n  };\n\n  // Apply overrides\n  for (var param in window.phantomLimbConfig) {\n    config[param] = window.phantomLimbConfig[param];\n  }\n\n  // Keep track of whether the mouse is down.\n  var mouseIsDown = false;\n\n  // A Finger is a representation on the screen.\n  // It keeps track of its position and the node that it's over.\n  function Finger() {\n    this.node = document.createElement('span');\n    this.node.classList.add('_phantom-limb_finger');\n    this.place();\n  }\n\n  Finger.prototype = {\n    node: null,\n\n    x: NaN,\n    y: NaN,\n\n    target: null,\n\n    place: function() {\n      document.body.appendChild(this.node);\n    },\n\n    hide: function() {\n      this.node.style.display = 'none';\n    },\n\n    show: function() {\n      this.node.style.display = '';\n    },\n\n    move: function(x, y) {\n      if (isNaN(x) || isNaN(y)) {\n        this.hide();\n        this.target = null;\n      } else {\n        this.show();\n\n        this.node.style.left = x + 'px';\n        this.node.style.top = y + 'px';\n\n        this.x = x;\n        this.y = y;\n\n        if (!mouseIsDown) this.target = document.elementFromPoint(x, y);\n      }\n    }\n  };\n\n  // We'll instantiate the fingers when we start.\n  var fingers = [];\n\n  // Create a synthetic event from a real event and a finger.\n  function createMouseEvent(eventName, originalEvent, finger) {\n    var e = document.createEvent('MouseEvent');\n\n    e.initMouseEvent(eventName, true, true,\n      originalEvent.view, originalEvent.detail,\n      finger.x || originalEvent.screenX, finger.y || originalEvent.screenY,\n      finger.x || originalEvent.clientX, finger.y || originalEvent.clientY,\n      originalEvent.ctrlKey, originalEvent.shiftKey,\n      originalEvent.altKey, originalEvent.metaKey,\n      originalEvent.button, finger.target || originalEvent.relatedTarget\n    );\n\n    e.synthetic = true;\n\n    // Set this so we can match shared targets later.\n    e._finger = finger;\n\n    return e;\n  }\n\n  var startDistance = NaN;\n  var startAngle = NaN;\n\n  // Given a mouse event, fire a touch event for each finger.\n  // Add the appropriate touch-specific event properties.\n  function fireTouchEvents(eventName, originalEvent) {\n    // All touch events, including \"touchend\".\n    var events = [];\n    var gestures = [];\n\n    // For each finger with a target, create a touch event.\n    fingers.forEach(function(finger) {\n      if (!finger.target) return;\n\n      // Convert \"ontouch*\" properties and attributes to listeners.\n      var onEventName = 'on' + eventName;\n\n      if (onEventName in finger.target) {\n        console.warn('Converting `' + onEventName + '` property to event listener.', finger.target);\n        finger.target.addEventListener(eventName, finger.target[onEventName], false);\n        delete finger.target[onEventName];\n      }\n\n      if (finger.target.hasAttribute(onEventName)) {\n        console.warn('Converting `' + onEventName + '` attribute to event listener.', finger.target);\n        var handler = new Function('event', finger.target.getAttribute(onEventName));\n        finger.target.addEventListener(eventName, handler, false);\n        finger.target.removeAttribute(onEventName);\n      }\n\n      // Set up a new event with the coordinates of the finger.\n      var touch = createMouseEvent(eventName, originalEvent, finger);\n\n      events.push(touch);\n    });\n\n    // Figure out scale and rotation.\n    if (events.length > 1) {\n      var x = events[0].pageX - events[1].pageX;\n      var y = events[0].pageY - events[1].pageY;\n\n      var distance = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n      var angle = Math.atan2(x, y) * (180 / Math.PI);\n\n      var gestureName = 'gesturechange';\n\n      if (eventName === 'touchstart') {\n        gestureName = 'gesturestart';\n        startDistance = distance;\n        startAngle = angle;\n      }\n\n      if (eventName === 'touchend') gestureName = 'gestureend';\n\n      events.forEach(function(event) {\n        var gesture = createMouseEvent(gestureName, event, event._finger);\n        gestures.push(gesture);\n      });\n\n      events.concat(gestures).forEach(function(event) {\n        event.scale = distance / startDistance;\n        event.rotation = startAngle - angle;\n      });\n    }\n\n    // Loop through the events array and fill in each touch array.\n    events.forEach(function(touch) {\n      touch.touches = events.filter(function(e) {\n        return ~e.type.indexOf('touch') && e.type !== 'touchend';\n      });\n\n      touch.changedTouches = events.filter(function(e) {\n        return ~e.type.indexOf('touch') && e._finger.target === touch._finger.target;\n      });\n\n      touch.targetTouches = touch.changedTouches.filter(function(e) {\n        return ~e.type.indexOf('touch') && e.type !== 'touchend';\n      });\n    });\n\n    // Then fire the events.\n    events.concat(gestures).forEach(function(event, i) {\n      event.identifier = i;\n      event._finger.target.dispatchEvent(event);\n    });\n  }\n\n  // Prevent all mousedown event from doing anything.\n  // We'll fire one manually at touchend.\n  function phantomTouchStart(e) {\n    if (e.synthetic) return;\n\n    mouseIsDown = true;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    fireTouchEvents('touchstart', e);\n  }\n\n  // The center between two fingers\n  var centerX = NaN;\n  var centerY = NaN;\n\n  // Set each finger's position target.\n  // Pressing alt engages the second finger.\n  // Pressing shift locks the second finger's position relative to the first's.\n  function moveFingers(e) {\n    // We'll use this if the second is locked with the first.\n    var changeX = e.clientX - fingers[0].x || 0;\n    var changeY = e.clientY - fingers[0].y || 0;\n\n    // The first finger just follows the mouse.\n    fingers[0].move(e.clientX, e.clientY);\n\n    // TODO: Determine modifier keys independent of mouse movement.\n\n    if (e.altKey) {\n      // Reset the center.\n      if (!centerX && !centerY) {\n        centerX = innerWidth / 2;\n        centerY = innerHeight / 2;\n      }\n\n      // Lock the center with the first finger.\n      if (e.shiftKey) {\n        centerX += changeX;\n        centerY += changeY;\n      }\n\n      var secondX = centerX + (centerX - e.clientX);\n      var secondY = centerY + (centerY - e.clientY);\n\n      fingers[1].move(secondX, secondY);\n    } else {\n      // Disengage the second finger.\n      fingers[1].move(NaN, NaN);\n\n      // Reset the center next time the alt key is held.\n      centerX = NaN;\n      centerY = NaN;\n    }\n  }\n\n  // Prevent all mousemove events from firing.\n  // We'll fire one (and only one) manually at touchend.\n  function phantomTouchMove(e) {\n    if (e.synthetic) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    moveFingers(e);\n\n    if (mouseIsDown) {\n      fireTouchEvents('touchmove', e);\n    }\n  }\n\n  // Prevent all mouseup events from firing.\n  // We'll fire one manually at touchend.\n  function phantomTouchEnd(e) {\n    if (e.synthetic) return;\n\n    mouseIsDown = false;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    fireTouchEvents('touchend', e);\n\n    fingers.forEach(function(finger) {\n      if (!finger.target) return;\n\n      // Mobile Safari moves all the mouse event to fire after the touchend event.\n      finger.target.dispatchEvent(createMouseEvent('mouseover', e, finger));\n      finger.target.dispatchEvent(createMouseEvent('mousemove', e, finger));\n      finger.target.dispatchEvent(createMouseEvent('mousedown', e, finger));\n\n      // TODO: These two only fire if content didn't change. How can we tell?\n      finger.target.dispatchEvent(createMouseEvent('mouseup', e, finger));\n      finger.target.dispatchEvent(createMouseEvent('click', e, finger));\n    });\n  }\n\n  // Prevent clicks. We'll handle them manually.\n  function phantomClick(e) {\n    if (e.synthetic) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  // Not entirely proud of this, but I can't serve CSS from GitHub\n  // and I want the bookmarklet to be as simple as possible.\n  var defaultCSS = ([\n    '._phantom-limb,',\n    '._phantom-limb a {',\n      'cursor: none !important;',\n    '}',\n    '._phantom-limb_finger {',\n      'background: rgba(128, 128, 128, 0.5);',\n      'border: 2px solid rgb(128, 128, 128);',\n      'border-radius: 50%;',\n      'display: none;',\n      'height: 44px;',\n      'margin: -22px 0 0 -22px;',\n      'pointer-events: none;',\n      'position: fixed;',\n      'width: 44px;',\n      'z-index: 999999' +\n    '}',\n    '._phantom-limb ._phantom-limb_finger {',\n      'display: block;',\n    '}'\n  ]).join('\\n');\n\n  if (config.style) {\n    var styleTag = document.createElement('style');\n    styleTag.id = '_phantom-limb_default-style';\n    styleTag.innerHTML = defaultCSS;\n    document.querySelector('head').appendChild(styleTag);\n  }\n\n  // On/off switch\n  function start() {\n    if (fingers.length === 0) fingers.push(new Finger(), new Finger());\n\n    document.addEventListener('mousedown', phantomTouchStart, true);\n    document.addEventListener('mousemove', phantomTouchMove, true);\n    document.addEventListener('mouseup', phantomTouchEnd, true);\n    document.addEventListener('click', phantomClick, true);\n\n    document.documentElement.classList.add('_phantom-limb');\n  }\n\n  function stop() {\n    document.removeEventListener('mousedown', phantomTouchStart, true);\n    document.removeEventListener('mousemove', phantomTouchMove, true);\n    document.removeEventListener('mouseup', phantomTouchEnd, true);\n    document.removeEventListener('click', phantomClick, true);\n\n    document.documentElement.classList.remove('_phantom-limb');\n  }\n\n  // Detect keyup, exit when esc.\n  function phantomKeyUp(e) {\n    if (e.keyCode === 27) {\n      if (document.documentElement.classList.contains('_phantom-limb')) {\n        stop();\n      } else {\n        start();\n      }\n    }\n  }\n\n  var phantomLimb = {\n    start: start,\n    stop: stop\n  };\n\n  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (phantomLimb),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  if (true) module.exports = phantomLimb;\n  window.phantomLimb = phantomLimb;\n\n  document.addEventListener('keyup', phantomKeyUp, false);\n\n  if (config.startOnLoad) addEventListener('DOMContentLoaded', start, false);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGhhbnRvbS1saW1iL2luZGV4LmpzP2RmZGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQixNQUFNO0FBQ04sNEJBQTRCO0FBQzVCLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CO0FBQ0EsTUFBTTtBQUNOLDJDQUEyQztBQUMzQyxzQkFBc0I7QUFDdEIsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLElBQTBDLEVBQUUsb0NBQU8sV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ3JFLE1BQU0sSUFBNkI7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc190b3VjaF9kZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICAgICAgfHwgJ29ubXNnZXN0dXJlY2hhbmdlJyBpbiB3aW5kb3c7IC8vIHdvcmtzIG9uIGllMTBcbn07XG5cbmlmKCFpc190b3VjaF9kZXZpY2UoKSkge1xuICAvLyBQaGFudG9tIExpbWJcbiAgLy8gLS0tLS0tLS0tLS0tXG4gIC8vIGh0dHA6Ly92aWV3aW5nbGVucy5jb20vcGhhbnRvbS1saW1iXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9icmlhbi1jL3BoYW50b20tbGltYlxuICAvLyBicmlhbi5jYXJzdGVuc2VuQGdtYWlsLmNvbVxuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuICB2YXIgY29uZmlnID0ge1xuICAgIHN0eWxlOiB0cnVlLFxuICAgIHN0YXJ0T25Mb2FkOiB0cnVlXG4gIH07XG5cbiAgLy8gQXBwbHkgb3ZlcnJpZGVzXG4gIGZvciAodmFyIHBhcmFtIGluIHdpbmRvdy5waGFudG9tTGltYkNvbmZpZykge1xuICAgIGNvbmZpZ1twYXJhbV0gPSB3aW5kb3cucGhhbnRvbUxpbWJDb25maWdbcGFyYW1dO1xuICB9XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBtb3VzZSBpcyBkb3duLlxuICB2YXIgbW91c2VJc0Rvd24gPSBmYWxzZTtcblxuICAvLyBBIEZpbmdlciBpcyBhIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzY3JlZW4uXG4gIC8vIEl0IGtlZXBzIHRyYWNrIG9mIGl0cyBwb3NpdGlvbiBhbmQgdGhlIG5vZGUgdGhhdCBpdCdzIG92ZXIuXG4gIGZ1bmN0aW9uIEZpbmdlcigpIHtcbiAgICB0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ19waGFudG9tLWxpbWJfZmluZ2VyJyk7XG4gICAgdGhpcy5wbGFjZSgpO1xuICB9XG5cbiAgRmluZ2VyLnByb3RvdHlwZSA9IHtcbiAgICBub2RlOiBudWxsLFxuXG4gICAgeDogTmFOLFxuICAgIHk6IE5hTixcblxuICAgIHRhcmdldDogbnVsbCxcblxuICAgIHBsYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH0sXG5cbiAgICBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuXG4gICAgICAgIHRoaXMubm9kZS5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIHRoaXMubm9kZS5zdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIGlmICghbW91c2VJc0Rvd24pIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gV2UnbGwgaW5zdGFudGlhdGUgdGhlIGZpbmdlcnMgd2hlbiB3ZSBzdGFydC5cbiAgdmFyIGZpbmdlcnMgPSBbXTtcblxuICAvLyBDcmVhdGUgYSBzeW50aGV0aWMgZXZlbnQgZnJvbSBhIHJlYWwgZXZlbnQgYW5kIGEgZmluZ2VyLlxuICBmdW5jdGlvbiBjcmVhdGVNb3VzZUV2ZW50KGV2ZW50TmFtZSwgb3JpZ2luYWxFdmVudCwgZmluZ2VyKSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuXG4gICAgZS5pbml0TW91c2VFdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsXG4gICAgICBvcmlnaW5hbEV2ZW50LnZpZXcsIG9yaWdpbmFsRXZlbnQuZGV0YWlsLFxuICAgICAgZmluZ2VyLnggfHwgb3JpZ2luYWxFdmVudC5zY3JlZW5YLCBmaW5nZXIueSB8fCBvcmlnaW5hbEV2ZW50LnNjcmVlblksXG4gICAgICBmaW5nZXIueCB8fCBvcmlnaW5hbEV2ZW50LmNsaWVudFgsIGZpbmdlci55IHx8IG9yaWdpbmFsRXZlbnQuY2xpZW50WSxcbiAgICAgIG9yaWdpbmFsRXZlbnQuY3RybEtleSwgb3JpZ2luYWxFdmVudC5zaGlmdEtleSxcbiAgICAgIG9yaWdpbmFsRXZlbnQuYWx0S2V5LCBvcmlnaW5hbEV2ZW50Lm1ldGFLZXksXG4gICAgICBvcmlnaW5hbEV2ZW50LmJ1dHRvbiwgZmluZ2VyLnRhcmdldCB8fCBvcmlnaW5hbEV2ZW50LnJlbGF0ZWRUYXJnZXRcbiAgICApO1xuXG4gICAgZS5zeW50aGV0aWMgPSB0cnVlO1xuXG4gICAgLy8gU2V0IHRoaXMgc28gd2UgY2FuIG1hdGNoIHNoYXJlZCB0YXJnZXRzIGxhdGVyLlxuICAgIGUuX2ZpbmdlciA9IGZpbmdlcjtcblxuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdmFyIHN0YXJ0RGlzdGFuY2UgPSBOYU47XG4gIHZhciBzdGFydEFuZ2xlID0gTmFOO1xuXG4gIC8vIEdpdmVuIGEgbW91c2UgZXZlbnQsIGZpcmUgYSB0b3VjaCBldmVudCBmb3IgZWFjaCBmaW5nZXIuXG4gIC8vIEFkZCB0aGUgYXBwcm9wcmlhdGUgdG91Y2gtc3BlY2lmaWMgZXZlbnQgcHJvcGVydGllcy5cbiAgZnVuY3Rpb24gZmlyZVRvdWNoRXZlbnRzKGV2ZW50TmFtZSwgb3JpZ2luYWxFdmVudCkge1xuICAgIC8vIEFsbCB0b3VjaCBldmVudHMsIGluY2x1ZGluZyBcInRvdWNoZW5kXCIuXG4gICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgIHZhciBnZXN0dXJlcyA9IFtdO1xuXG4gICAgLy8gRm9yIGVhY2ggZmluZ2VyIHdpdGggYSB0YXJnZXQsIGNyZWF0ZSBhIHRvdWNoIGV2ZW50LlxuICAgIGZpbmdlcnMuZm9yRWFjaChmdW5jdGlvbihmaW5nZXIpIHtcbiAgICAgIGlmICghZmluZ2VyLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgICAvLyBDb252ZXJ0IFwib250b3VjaCpcIiBwcm9wZXJ0aWVzIGFuZCBhdHRyaWJ1dGVzIHRvIGxpc3RlbmVycy5cbiAgICAgIHZhciBvbkV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWU7XG5cbiAgICAgIGlmIChvbkV2ZW50TmFtZSBpbiBmaW5nZXIudGFyZ2V0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29udmVydGluZyBgJyArIG9uRXZlbnROYW1lICsgJ2AgcHJvcGVydHkgdG8gZXZlbnQgbGlzdGVuZXIuJywgZmluZ2VyLnRhcmdldCk7XG4gICAgICAgIGZpbmdlci50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZpbmdlci50YXJnZXRbb25FdmVudE5hbWVdLCBmYWxzZSk7XG4gICAgICAgIGRlbGV0ZSBmaW5nZXIudGFyZ2V0W29uRXZlbnROYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmdlci50YXJnZXQuaGFzQXR0cmlidXRlKG9uRXZlbnROYW1lKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvbnZlcnRpbmcgYCcgKyBvbkV2ZW50TmFtZSArICdgIGF0dHJpYnV0ZSB0byBldmVudCBsaXN0ZW5lci4nLCBmaW5nZXIudGFyZ2V0KTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBuZXcgRnVuY3Rpb24oJ2V2ZW50JywgZmluZ2VyLnRhcmdldC5nZXRBdHRyaWJ1dGUob25FdmVudE5hbWUpKTtcbiAgICAgICAgZmluZ2VyLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICBmaW5nZXIudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShvbkV2ZW50TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBhIG5ldyBldmVudCB3aXRoIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZmluZ2VyLlxuICAgICAgdmFyIHRvdWNoID0gY3JlYXRlTW91c2VFdmVudChldmVudE5hbWUsIG9yaWdpbmFsRXZlbnQsIGZpbmdlcik7XG5cbiAgICAgIGV2ZW50cy5wdXNoKHRvdWNoKTtcbiAgICB9KTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgc2NhbGUgYW5kIHJvdGF0aW9uLlxuICAgIGlmIChldmVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIHggPSBldmVudHNbMF0ucGFnZVggLSBldmVudHNbMV0ucGFnZVg7XG4gICAgICB2YXIgeSA9IGV2ZW50c1swXS5wYWdlWSAtIGV2ZW50c1sxXS5wYWdlWTtcblxuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih4LCB5KSAqICgxODAgLyBNYXRoLlBJKTtcblxuICAgICAgdmFyIGdlc3R1cmVOYW1lID0gJ2dlc3R1cmVjaGFuZ2UnO1xuXG4gICAgICBpZiAoZXZlbnROYW1lID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgZ2VzdHVyZU5hbWUgPSAnZ2VzdHVyZXN0YXJ0JztcbiAgICAgICAgc3RhcnREaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudE5hbWUgPT09ICd0b3VjaGVuZCcpIGdlc3R1cmVOYW1lID0gJ2dlc3R1cmVlbmQnO1xuXG4gICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgZ2VzdHVyZSA9IGNyZWF0ZU1vdXNlRXZlbnQoZ2VzdHVyZU5hbWUsIGV2ZW50LCBldmVudC5fZmluZ2VyKTtcbiAgICAgICAgZ2VzdHVyZXMucHVzaChnZXN0dXJlKTtcbiAgICAgIH0pO1xuXG4gICAgICBldmVudHMuY29uY2F0KGdlc3R1cmVzKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnNjYWxlID0gZGlzdGFuY2UgLyBzdGFydERpc3RhbmNlO1xuICAgICAgICBldmVudC5yb3RhdGlvbiA9IHN0YXJ0QW5nbGUgLSBhbmdsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgZXZlbnRzIGFycmF5IGFuZCBmaWxsIGluIGVhY2ggdG91Y2ggYXJyYXkuXG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHRvdWNoLnRvdWNoZXMgPSBldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIH5lLnR5cGUuaW5kZXhPZigndG91Y2gnKSAmJiBlLnR5cGUgIT09ICd0b3VjaGVuZCc7XG4gICAgICB9KTtcblxuICAgICAgdG91Y2guY2hhbmdlZFRvdWNoZXMgPSBldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIH5lLnR5cGUuaW5kZXhPZigndG91Y2gnKSAmJiBlLl9maW5nZXIudGFyZ2V0ID09PSB0b3VjaC5fZmluZ2VyLnRhcmdldDtcbiAgICAgIH0pO1xuXG4gICAgICB0b3VjaC50YXJnZXRUb3VjaGVzID0gdG91Y2guY2hhbmdlZFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIH5lLnR5cGUuaW5kZXhPZigndG91Y2gnKSAmJiBlLnR5cGUgIT09ICd0b3VjaGVuZCc7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFRoZW4gZmlyZSB0aGUgZXZlbnRzLlxuICAgIGV2ZW50cy5jb25jYXQoZ2VzdHVyZXMpLmZvckVhY2goZnVuY3Rpb24oZXZlbnQsIGkpIHtcbiAgICAgIGV2ZW50LmlkZW50aWZpZXIgPSBpO1xuICAgICAgZXZlbnQuX2Zpbmdlci50YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBQcmV2ZW50IGFsbCBtb3VzZWRvd24gZXZlbnQgZnJvbSBkb2luZyBhbnl0aGluZy5cbiAgLy8gV2UnbGwgZmlyZSBvbmUgbWFudWFsbHkgYXQgdG91Y2hlbmQuXG4gIGZ1bmN0aW9uIHBoYW50b21Ub3VjaFN0YXJ0KGUpIHtcbiAgICBpZiAoZS5zeW50aGV0aWMpIHJldHVybjtcblxuICAgIG1vdXNlSXNEb3duID0gdHJ1ZTtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgZmlyZVRvdWNoRXZlbnRzKCd0b3VjaHN0YXJ0JywgZSk7XG4gIH1cblxuICAvLyBUaGUgY2VudGVyIGJldHdlZW4gdHdvIGZpbmdlcnNcbiAgdmFyIGNlbnRlclggPSBOYU47XG4gIHZhciBjZW50ZXJZID0gTmFOO1xuXG4gIC8vIFNldCBlYWNoIGZpbmdlcidzIHBvc2l0aW9uIHRhcmdldC5cbiAgLy8gUHJlc3NpbmcgYWx0IGVuZ2FnZXMgdGhlIHNlY29uZCBmaW5nZXIuXG4gIC8vIFByZXNzaW5nIHNoaWZ0IGxvY2tzIHRoZSBzZWNvbmQgZmluZ2VyJ3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGZpcnN0J3MuXG4gIGZ1bmN0aW9uIG1vdmVGaW5nZXJzKGUpIHtcbiAgICAvLyBXZSdsbCB1c2UgdGhpcyBpZiB0aGUgc2Vjb25kIGlzIGxvY2tlZCB3aXRoIHRoZSBmaXJzdC5cbiAgICB2YXIgY2hhbmdlWCA9IGUuY2xpZW50WCAtIGZpbmdlcnNbMF0ueCB8fCAwO1xuICAgIHZhciBjaGFuZ2VZID0gZS5jbGllbnRZIC0gZmluZ2Vyc1swXS55IHx8IDA7XG5cbiAgICAvLyBUaGUgZmlyc3QgZmluZ2VyIGp1c3QgZm9sbG93cyB0aGUgbW91c2UuXG4gICAgZmluZ2Vyc1swXS5tb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgIC8vIFRPRE86IERldGVybWluZSBtb2RpZmllciBrZXlzIGluZGVwZW5kZW50IG9mIG1vdXNlIG1vdmVtZW50LlxuXG4gICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICAvLyBSZXNldCB0aGUgY2VudGVyLlxuICAgICAgaWYgKCFjZW50ZXJYICYmICFjZW50ZXJZKSB7XG4gICAgICAgIGNlbnRlclggPSBpbm5lcldpZHRoIC8gMjtcbiAgICAgICAgY2VudGVyWSA9IGlubmVySGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgLy8gTG9jayB0aGUgY2VudGVyIHdpdGggdGhlIGZpcnN0IGZpbmdlci5cbiAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgIGNlbnRlclggKz0gY2hhbmdlWDtcbiAgICAgICAgY2VudGVyWSArPSBjaGFuZ2VZO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Vjb25kWCA9IGNlbnRlclggKyAoY2VudGVyWCAtIGUuY2xpZW50WCk7XG4gICAgICB2YXIgc2Vjb25kWSA9IGNlbnRlclkgKyAoY2VudGVyWSAtIGUuY2xpZW50WSk7XG5cbiAgICAgIGZpbmdlcnNbMV0ubW92ZShzZWNvbmRYLCBzZWNvbmRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGlzZW5nYWdlIHRoZSBzZWNvbmQgZmluZ2VyLlxuICAgICAgZmluZ2Vyc1sxXS5tb3ZlKE5hTiwgTmFOKTtcblxuICAgICAgLy8gUmVzZXQgdGhlIGNlbnRlciBuZXh0IHRpbWUgdGhlIGFsdCBrZXkgaXMgaGVsZC5cbiAgICAgIGNlbnRlclggPSBOYU47XG4gICAgICBjZW50ZXJZID0gTmFOO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByZXZlbnQgYWxsIG1vdXNlbW92ZSBldmVudHMgZnJvbSBmaXJpbmcuXG4gIC8vIFdlJ2xsIGZpcmUgb25lIChhbmQgb25seSBvbmUpIG1hbnVhbGx5IGF0IHRvdWNoZW5kLlxuICBmdW5jdGlvbiBwaGFudG9tVG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoZS5zeW50aGV0aWMpIHJldHVybjtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgbW92ZUZpbmdlcnMoZSk7XG5cbiAgICBpZiAobW91c2VJc0Rvd24pIHtcbiAgICAgIGZpcmVUb3VjaEV2ZW50cygndG91Y2htb3ZlJywgZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJldmVudCBhbGwgbW91c2V1cCBldmVudHMgZnJvbSBmaXJpbmcuXG4gIC8vIFdlJ2xsIGZpcmUgb25lIG1hbnVhbGx5IGF0IHRvdWNoZW5kLlxuICBmdW5jdGlvbiBwaGFudG9tVG91Y2hFbmQoZSkge1xuICAgIGlmIChlLnN5bnRoZXRpYykgcmV0dXJuO1xuXG4gICAgbW91c2VJc0Rvd24gPSBmYWxzZTtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgZmlyZVRvdWNoRXZlbnRzKCd0b3VjaGVuZCcsIGUpO1xuXG4gICAgZmluZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbmdlcikge1xuICAgICAgaWYgKCFmaW5nZXIudGFyZ2V0KSByZXR1cm47XG5cbiAgICAgIC8vIE1vYmlsZSBTYWZhcmkgbW92ZXMgYWxsIHRoZSBtb3VzZSBldmVudCB0byBmaXJlIGFmdGVyIHRoZSB0b3VjaGVuZCBldmVudC5cbiAgICAgIGZpbmdlci50YXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVNb3VzZUV2ZW50KCdtb3VzZW92ZXInLCBlLCBmaW5nZXIpKTtcbiAgICAgIGZpbmdlci50YXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVNb3VzZUV2ZW50KCdtb3VzZW1vdmUnLCBlLCBmaW5nZXIpKTtcbiAgICAgIGZpbmdlci50YXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCBlLCBmaW5nZXIpKTtcblxuICAgICAgLy8gVE9ETzogVGhlc2UgdHdvIG9ubHkgZmlyZSBpZiBjb250ZW50IGRpZG4ndCBjaGFuZ2UuIEhvdyBjYW4gd2UgdGVsbD9cbiAgICAgIGZpbmdlci50YXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVNb3VzZUV2ZW50KCdtb3VzZXVwJywgZSwgZmluZ2VyKSk7XG4gICAgICBmaW5nZXIudGFyZ2V0LmRpc3BhdGNoRXZlbnQoY3JlYXRlTW91c2VFdmVudCgnY2xpY2snLCBlLCBmaW5nZXIpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgY2xpY2tzLiBXZSdsbCBoYW5kbGUgdGhlbSBtYW51YWxseS5cbiAgZnVuY3Rpb24gcGhhbnRvbUNsaWNrKGUpIHtcbiAgICBpZiAoZS5zeW50aGV0aWMpIHJldHVybjtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgLy8gTm90IGVudGlyZWx5IHByb3VkIG9mIHRoaXMsIGJ1dCBJIGNhbid0IHNlcnZlIENTUyBmcm9tIEdpdEh1YlxuICAvLyBhbmQgSSB3YW50IHRoZSBib29rbWFya2xldCB0byBiZSBhcyBzaW1wbGUgYXMgcG9zc2libGUuXG4gIHZhciBkZWZhdWx0Q1NTID0gKFtcbiAgICAnLl9waGFudG9tLWxpbWIsJyxcbiAgICAnLl9waGFudG9tLWxpbWIgYSB7JyxcbiAgICAgICdjdXJzb3I6IG5vbmUgIWltcG9ydGFudDsnLFxuICAgICd9JyxcbiAgICAnLl9waGFudG9tLWxpbWJfZmluZ2VyIHsnLFxuICAgICAgJ2JhY2tncm91bmQ6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC41KTsnLFxuICAgICAgJ2JvcmRlcjogMnB4IHNvbGlkIHJnYigxMjgsIDEyOCwgMTI4KTsnLFxuICAgICAgJ2JvcmRlci1yYWRpdXM6IDUwJTsnLFxuICAgICAgJ2Rpc3BsYXk6IG5vbmU7JyxcbiAgICAgICdoZWlnaHQ6IDQ0cHg7JyxcbiAgICAgICdtYXJnaW46IC0yMnB4IDAgMCAtMjJweDsnLFxuICAgICAgJ3BvaW50ZXItZXZlbnRzOiBub25lOycsXG4gICAgICAncG9zaXRpb246IGZpeGVkOycsXG4gICAgICAnd2lkdGg6IDQ0cHg7JyxcbiAgICAgICd6LWluZGV4OiA5OTk5OTknICtcbiAgICAnfScsXG4gICAgJy5fcGhhbnRvbS1saW1iIC5fcGhhbnRvbS1saW1iX2ZpbmdlciB7JyxcbiAgICAgICdkaXNwbGF5OiBibG9jazsnLFxuICAgICd9J1xuICBdKS5qb2luKCdcXG4nKTtcblxuICBpZiAoY29uZmlnLnN0eWxlKSB7XG4gICAgdmFyIHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZVRhZy5pZCA9ICdfcGhhbnRvbS1saW1iX2RlZmF1bHQtc3R5bGUnO1xuICAgIHN0eWxlVGFnLmlubmVySFRNTCA9IGRlZmF1bHRDU1M7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgfVxuXG4gIC8vIE9uL29mZiBzd2l0Y2hcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgaWYgKGZpbmdlcnMubGVuZ3RoID09PSAwKSBmaW5nZXJzLnB1c2gobmV3IEZpbmdlcigpLCBuZXcgRmluZ2VyKCkpO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgcGhhbnRvbVRvdWNoU3RhcnQsIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHBoYW50b21Ub3VjaE1vdmUsIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBwaGFudG9tVG91Y2hFbmQsIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcGhhbnRvbUNsaWNrLCB0cnVlKTtcblxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdfcGhhbnRvbS1saW1iJyk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHBoYW50b21Ub3VjaFN0YXJ0LCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBwaGFudG9tVG91Y2hNb3ZlLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgcGhhbnRvbVRvdWNoRW5kLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHBoYW50b21DbGljaywgdHJ1ZSk7XG5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnX3BoYW50b20tbGltYicpO1xuICB9XG5cbiAgLy8gRGV0ZWN0IGtleXVwLCBleGl0IHdoZW4gZXNjLlxuICBmdW5jdGlvbiBwaGFudG9tS2V5VXAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnX3BoYW50b20tbGltYicpKSB7XG4gICAgICAgIHN0b3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBoYW50b21MaW1iID0ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBzdG9wOiBzdG9wXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKHBoYW50b21MaW1iKTtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IHBoYW50b21MaW1iO1xuICB3aW5kb3cucGhhbnRvbUxpbWIgPSBwaGFudG9tTGltYjtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHBoYW50b21LZXlVcCwgZmFsc2UpO1xuXG4gIGlmIChjb25maWcuc3RhcnRPbkxvYWQpIGFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBzdGFydCwgZmFsc2UpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcGhhbnRvbS1saW1iL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35\n");

/***/ })

/******/ });